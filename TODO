- [ ] babel-parse all files
- [ ] use TSConfig to determine potential 'names' for each file? I think on transpiled JS, this is taken care of for us
- [ ] Determine external dependencies for each file
    - [ ] walk AST for a file
    - [ ] let visitors call in
        - [ ] create visitors for the various import/export formats
            - [x] `import 'foo'`
            - [x] `import * as foo from 'foo'`
            - [x] `import foo from 'foo'`
            - [x] ` import {default as foo, foo2 as foo2 } from 'foo'`
            - [x] `export {...} from 'foo'`
            - [x] `export * from 'foo'`
            - [ ] `import foo = require('foo')`
            - [x] Single-module call imports, which take a module name as their only param
                - [x] import()
                - [x] require()
                - [x] require.resolve()
                - [x] require.include()
                - [x] require.resolveWeak()
            - [x] Variable-length module call imports, which take an array of module names as their first param
                - [x] require.ensure()
                - [x] require.context(), which also takes whether to include subdirectories as its second param
- [ ] Build the dependency graph using the files and their external dependencies
    - [ ] Keep track of cycles of files and files that are leaf nodes
    - [ ] Edges should be incident to a file, from the files it depends on
- [ ] Get each file's transitive hash (aka trash) by walking the dependency graph, starting from each cycle and leaf node
        - [ ] For each leaf node, hash its path+name+contents
        - [ ] For each cycle, hash all paths+names+contents together in lexical order
        - [ ] For each other node, hash its path+name+contents together with its dependencies' hashes in lexical order
- [ ] Build a list of files and hashes