- [ ] babel-parse all files
- [ ] use TSConfig to determine potential 'names' for each file? I think on transpiled JS, this is taken care of for us
- [X] Determine external dependencies for each file
    - [X] walk AST for a file
    - [x] let visitors call in
        - [x] create visitors for the various import/export formats
            - [x] `import 'foo'`
            - [x] `import * as foo from 'foo'`
            - [x] `import foo from 'foo'`
            - [x] ` import {default as foo, foo2 as foo2 } from 'foo'`
            - [x] `export {...} from 'foo'`
            - [x] `export * from 'foo'`
            - [x] `import foo = require('foo')`
            - [x] Single-module call imports, which take a module name as their only param
                - [x] import()
                - [x] require()
                - [x] require.resolve()
                - [x] require.include()
                - [x] require.resolveWeak()
            - [x] Variable-length module call imports, which take an array of module names as their first param
                - [x] require.ensure()
                - [x] require.context(), which also takes whether to include subdirectories as its second param
    - [X] Classify dependencies as wildcard, native Node API, or file dependencies
    - [X] Using an optional path mapping dictionary (a la TypeScript), convert all wildcard and file dependencies 
    - [X] Comparing against the list of all files, convert wildcard dependencies into real dependencies
- [ ] Build the dependency graph using the files and their external dependencies
    - [ ] Keep track of files that are leaf nodes
    - [ ] Edges should be incident to a file, from the files it depends on
    - [ ] Dependencies on a native Node API should be mapped to a special node that contains the node version
    - [ ] Dependencies with a wildcard should each be mapped to a unique special node that depends on all files that match that wildcard
- [ ] Get each file's transitive hash (aka trash) by walking the dependency graph
        - [ ] Starting from each leaf node, compute each node's hash and transitive dependencies:
                - [ ] Perform [Purdom's algorithm] to build the transitive closure of the dependency graph
                    - [X] Tarjan's algorithm to produce the graph of SCC's
                    - [X] Toposort the SCCs
                    - [ ] Compute the transitive closure of the graph of SCC's
                    - [ ] Reconstruct the transitive closure of the original graph from the graph of SCC's
                - [ ] Call the node's hash its path+name+contents
                - [ ] Add the current node and its dependencies to the set of transitiveDependencies of each node that points to the current node
                - [ ] Add to the list of nodes to visit: each node that points to the current node, but doesn't yet have a hash
        - [ ] For each node, get the trash:
                - [ ] Call the node's trash the hash of (the node's hash + the hash of each transitive dependency, sorted lexicographically)
        
- [ ] Build a list of files to (trash, hash, transitiveDependencies)

[Purdom's algorithm]:https://algowiki-project.org/en/Purdom's_algorithm#Macro_structure_of_the_algorithm